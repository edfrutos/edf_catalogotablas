# app/routes/main_routes.py

from flask import Blueprint, render_template, redirect, url_for, session, flash, current_app, request
from app.decorators import login_required
from bson.objectid import ObjectId
from bson.errors import InvalidId
import logging
from werkzeug.routing import BuildError
import os
from werkzeug.utils import secure_filename
import secrets
from datetime import datetime
import openpyxl
from openpyxl import Workbook
import csv
import uuid

main_bp = Blueprint('main', __name__)
logger = logging.getLogger(__name__)

@main_bp.route('/')
def index():
    # Redirigir a welcome si no está logueado
    if 'user_id' not in session:
        return redirect(url_for('main.welcome'))
    return redirect(url_for('main.dashboard'))

@main_bp.route('/welcome')
def welcome():
    return render_template('welcome.html')

@main_bp.route('/dashboard')
# # @login_required
def dashboard():
    try:
        role = session.get('role', 'user')
        
        if role == 'admin':
            # Verificar si existe el endpoint admin.dashboard_admin
            try:
                return redirect(url_for('admin.dashboard_admin'))
            except BuildError:
                logger.warning("Endpoint admin.dashboard_admin no encontrado, redirigiendo a dashboard_user")
                return redirect(url_for('main.dashboard_user'))
        elif role == 'user':
            return redirect(url_for('main.dashboard_user'))
        else:
            flash('Rol desconocido. Contacte con el administrador.', 'error')
            return redirect(url_for('main.welcome'))
    except Exception as e:
        logger.error(f"Error en dashboard: {str(e)}", exc_info=True)
        flash("Error al cargar el dashboard. Por favor intente nuevamente.", "error")
        # Asegurarse de que siempre devuelva una respuesta válida
        return render_template('welcome.html')

@main_bp.route('/dashboard_user')
def dashboard_user():
    # Permitir acceso sin verificación de sesión, pero mostrar solo tablas del usuario
    spreadsheets_collection = getattr(current_app, 'spreadsheets_collection', None)
    if spreadsheets_collection is None and hasattr(current_app, 'db'):
        spreadsheets_collection = current_app.db['spreadsheets']
    if spreadsheets_collection is None:
        flash('No se pudo acceder a las tablas del usuario. Contacte con el administrador.', 'error')
        return redirect(url_for('main.dashboard'))
        
    # Obtener el nombre de usuario de la sesión o usar un valor predeterminado
    owner = session.get('username') or session.get('email') or 'usuario_normal'
    role = session.get('role', 'user')
    
    # Los administradores ven todas las tablas, los usuarios normales solo las suyas
    if role == 'admin':
        tablas = list(spreadsheets_collection.find().sort('created_at', -1))
        logger.info(f"[ADMIN] Mostrando todas las tablas para el administrador {owner}")
    else:
        tablas = list(spreadsheets_collection.find({"owner": owner}).sort('created_at', -1))
        logger.info(f"[USER] Mostrando solo las tablas del usuario {owner}")
    
    # Obtener catálogos del usuario
    try:
        from app.extensions import mongo
        if role == 'admin':
            catalogs = list(mongo.db.catalogs.find())
            logger.info(f"[ADMIN] Mostrando todos los catálogos para el administrador {owner}")
        else:
            catalogs = list(mongo.db.catalogs.find({"created_by": owner}))
            logger.info(f"[USER] Mostrando solo los catálogos del usuario {owner}")
        
        # Agregar _id_str a cada catálogo para facilitar su uso en las plantillas
        for catalog in catalogs:
            catalog['_id_str'] = str(catalog['_id'])
    except Exception as e:
        logger.error(f"Error al obtener catálogos: {str(e)}")
        catalogs = []
        flash('No se pudieron cargar los catálogos. Contacte con el administrador.', 'warning')
        
    return render_template('dashboard_unificado.html', tablas=tablas, catalogs=catalogs)

@main_bp.route("/editar/<id>", methods=["GET", "POST"])
def editar(id):
    # Eliminar verificaciones de sesión y permisos
    # if "username" not in session:
    #     return redirect(url_for("auth.login"))
    if "selected_table" not in session:
        # Si no hay tabla seleccionada, usar el ID proporcionado para buscar la tabla
        try:
            table_info = current_app.spreadsheets_collection.find_one({"_id": ObjectId(id)})
            if table_info:
                selected_table = table_info.get("filename")
                session["selected_table"] = selected_table
            else:
                flash("Tabla no encontrada.", "error")
                return redirect(url_for("main.tables"))
        except Exception as e:
            logger.error(f"Error al buscar tabla por ID: {str(e)}")
            flash("Error al buscar la tabla.", "error")
            return redirect(url_for("main.tables"))
    else:
        selected_table = session["selected_table"]
        table_info = current_app.spreadsheets_collection.find_one({"filename": selected_table})
        if not table_info:
            flash("Tabla no encontrada.", "error")
            return redirect(url_for("main.tables"))
    # Control de acceso: solo admin o dueño puede editar
    if session.get("role") != "admin" and table_info.get("owner") != session.get("username"):
        flash("No tiene permisos para editar esta tabla", "error")
        return redirect(url_for("main.tables"))

    if request.method == "POST":
        nuevo_nombre = request.form.get("nombre", "").strip()
        nuevos_headers = [h.strip() for h in request.form.get("headers", "").split(",") if h.strip()]
        update = {}
        if nuevo_nombre:
            update["name"] = nuevo_nombre
        if nuevos_headers:
            update["headers"] = nuevos_headers
        if update:
            current_app.spreadsheets_collection.update_one(
                {"filename": selected_table},
                {"$set": update}
            )
            flash("Tabla actualizada correctamente.", "success")
        else:
            flash("No se detectaron cambios.", "info")
        return redirect(url_for("main.ver_tabla", table_id=id))

    # GET: mostrar formulario de edición
    return render_template(
        "editar_tabla.html",
        table=table_info
    )

@main_bp.route('/ver_tabla/<table_id>')
# # @login_required
def ver_tabla(table_id):
    try:
        table = current_app.spreadsheets_collection.find_one({'_id': ObjectId(table_id)})
        current_app.logger.info(f"[DEBUG][VISIONADO] Tabla encontrada: {table}")
        if not table:
            flash('Tabla no encontrada.', 'error')
            return redirect(url_for('main.dashboard_user'))
        
        # Log de sesión y permisos
        current_app.logger.info(f"[DEBUG][VISIONADO] Sesión: {dict(session)}")
        current_app.logger.info(f"[DEBUG][VISIONADO] table.owner: {table.get('owner')}, session.username: {session.get('username')}, session.role: {session.get('role')}")
        
        # Verificar permisos: solo el propietario o admin puede ver la tabla
        if session.get('role') != 'admin' and table.get('owner') != session.get('username'):
            mensaje = (
                f"No tiene permisos para ver esta tabla. "
                f"(owner={table.get('owner')}, username={session.get('username')}, role={session.get('role')})"
            )
            flash(mensaje, "error")
            return redirect(url_for('main.dashboard_user'))
        
        # Si llegamos aquí, el usuario tiene permisos para ver la tabla
        return render_template('ver_tabla.html', table=table)
    except BuildError as e:
        logger.error(f"BuildError en ver_tabla: {str(e)}", exc_info=True)
        flash("Error interno: ruta no encontrada o mal configurada.", "danger")
        return render_template("error.html", error="Error interno: ruta no encontrada o mal configurada.")
        return redirect(url_for('main.dashboard_user'))
    except Exception as e:
        logger.error(f"Error inesperado en ver_tabla: {str(e)}", exc_info=True)
        flash("Error interno inesperado.", "danger")
        return redirect(url_for('main.dashboard_user'))

@main_bp.route('/select_table/<table_id>')
def select_table(table_id):
    if not (session.get('username') or session.get('email')):
        return redirect(url_for("auth.login"))
    table = current_app.spreadsheets_collection.find_one({"_id": ObjectId(table_id)})
    if not table:
        flash("Tabla no encontrada.", "error")
        return redirect(url_for("tables"))
    session["selected_table"] = table["filename"]
    session["selected_table_id"] = str(table["_id"])
    session["selected_table_name"] = table.get("name", "Sin nombre")
    return redirect(url_for("main.ver_tabla", table_id=table_id))

@main_bp.route('/perfil')
# # @login_required
def perfil():
    users_collection = getattr(current_app, 'users_collection', None)
    if users_collection is None and hasattr(current_app, 'mongo'):
        users_collection = current_app.mongo.db.users
    user = users_collection.find_one({'_id': ObjectId(session['user_id'])})
    return render_template('perfil.html', user=user)

@main_bp.route('/editar_perfil', methods=['GET', 'POST'])
# # @login_required
def editar_perfil():
    users_collection = getattr(current_app, 'users_collection', None)
    if users_collection is None and hasattr(current_app, 'mongo'):
        users_collection = current_app.mongo.db.users
    user = users_collection.find_one({'_id': ObjectId(session['user_id'])})
    if request.method == 'POST':
        nuevo_nombre = request.form.get('nombre', '').strip()
        nuevo_email = request.form.get('email', '').strip()
        foto = request.files.get('foto')
        update = {}
        if nuevo_nombre:
            update['nombre'] = nuevo_nombre
        if nuevo_email:
            update['email'] = nuevo_email
        if foto and foto.filename:
            filename = secure_filename(foto.filename)
            unique_filename = f"{secrets.token_hex(8)}_{filename}"
            # Antes de usar UPLOAD_FOLDER, comprobamos que existe en la config
            if "UPLOAD_FOLDER" not in current_app.config:
                    current_app.config["UPLOAD_FOLDER"] = os.path.join(os.path.dirname(os.path.abspath(__file__)), '..', 'uploads')
                    os.makedirs(current_app.config["UPLOAD_FOLDER"], exist_ok=True)
                    logger.info(f"Carpeta de uploads creada: {current_app.config['UPLOAD_FOLDER']}")
        else:
            flash('No se detectaron cambios.', 'info')
    return render_template('editar_perfil.html', user=user)

@main_bp.route('/editar_fila/<fila_id>', methods=['GET', 'POST'])
# # @login_required
def editar_fila(fila_id):
    current_app.logger.info(f"[DEBUG] Valor recibido para fila_id: {fila_id}")
    # Buscar la fila por _id como string
    fila = current_app.catalog_collection.find_one({'_id': fila_id})
    if not fila:
        flash('Fila no encontrada.', 'error')
        return redirect(url_for('tables'))
    # Obtener info de la tabla
    table_info = current_app.spreadsheets_collection.find_one({'filename': fila['table']})
    if not table_info:
        flash('Tabla asociada no encontrada.', 'error')
        return redirect(url_for('tables'))
    # Control de acceso: solo el propietario o admin puede editar filas
    if session.get('role') != 'admin' and table_info.get('owner') != session.get('username'):
        flash('No tienes permisos para editar esta fila.', 'error')
        return redirect(url_for('main.ver_tabla', table_id=str(table_info['_id'])))
    headers = table_info.get('headers', [])
    if request.method == 'POST':
        update_data = {}
        for header in headers:
            if header != 'Número' and header != 'Imagenes':
                update_data[header] = request.form.get(header, '').strip()
        current_app.catalog_collection.update_one({'_id': fila_id}, {'$set': update_data})
        flash('Fila actualizada correctamente.', 'success')
        return redirect(url_for('main.ver_tabla', table_id=str(table_info['_id'])))
    return render_template('editar_fila.html', fila=fila, headers=headers, catalog=table_info)

@main_bp.route("/tables", methods=["GET", "POST"])
# # @login_required
def tables():
    # Eliminar verificación de sesión para permitir acceso sin restricciones
    # if "username" not in session:
    #     flash("Debe iniciar sesión para acceder a las tablas", "warning")
    #     return redirect(url_for("auth.login"))
        
    owner = "usuario_predeterminado"
    
    # Verificar que la colección de spreadsheets esté disponible
    if not hasattr(current_app, 'spreadsheets_collection'):
        logger.error("Error: No se encontró la colección spreadsheets_collection en current_app")
        flash("Error de conexión a la base de datos. Por favor, contacte al administrador.", "danger")
        return render_template("error.html", error="Error de conexión a la base de datos")
    
    # Método GET: Mostrar tablas existentes
    if request.method == "GET":
        try:
            # Los administradores ven todas las tablas, los usuarios normales solo las suyas
            role = session.get("role", "user")
            if role == "admin":
                todas_las_tablas = list(current_app.spreadsheets_collection.find())
                logger.info(f"[ADMIN] Mostrando todas las tablas para el administrador {owner}")
            else:
                todas_las_tablas = list(current_app.spreadsheets_collection.find({"owner": owner}))
                logger.info(f"[USER] Mostrando solo las tablas del usuario {owner}")
            
            current_app.logger.info(f"[VISIONADO] Tablas encontradas para {owner}: {todas_las_tablas}")
            return render_template("tables.html", tables=todas_las_tablas)
        except Exception as e:
            logger.error(f"Error al listar tablas: {str(e)}", exc_info=True)
            flash("Error al obtener las tablas. Por favor, inténtelo de nuevo.", "danger")
            return render_template("error.html", error="Error al obtener las tablas")
    
    # Método POST: Crear nueva tabla
    try:
        table_name = request.form.get("table_name", "").strip()
        import_file = request.files.get("import_table")
        
        # Validar nombre de tabla
        if not table_name:
            flash("El nombre de la tabla es obligatorio.", "error")
            return redirect(url_for("main.tables"))

        # Comprobar duplicados para el mismo usuario
        if current_app.spreadsheets_collection.find_one({"owner": owner, "name": table_name}):
            flash("Ya existe una tabla con ese nombre.", "error")
            return redirect(url_for("main.tables"))
            
        # Procesar archivo importado o crear tabla nueva
        if import_file and import_file.filename:
            try:
                ext = os.path.splitext(import_file.filename)[1].lower()
                unique_id = uuid.uuid4().hex
                filename = f"table_{unique_id}{ext}"
                
                if "UPLOAD_FOLDER" not in current_app.config:
                    flash("Error en la configuración del servidor. Contacte al administrador.", "danger")
                    return redirect(url_for("main.tables"))
                    
                filepath = os.path.join(current_app.config["UPLOAD_FOLDER"], filename)
                import_file.save(filepath)
                
                # Procesar archivo según su tipo
                headers = None
                rows = []
                
                if ext in [".xlsx", ".xlsm", ".xltx", ".xltm"]:
                    try:
                        wb = openpyxl.load_workbook(filepath)
                        hoja = wb.active
                        headers = list(next(hoja.iter_rows(min_row=1, max_row=1, values_only=True)))
                        for row in hoja.iter_rows(min_row=2, values_only=True):
                            if any(row):
                                rows.append({h: (row[i] if i < len(row) else '') for i, h in enumerate(headers)})
                        wb.close()
                    except Exception as e:
                        flash(f"Error al leer el archivo Excel: {str(e)}", "error")
                        return redirect(url_for("main.tables"))
                elif ext == ".csv":
                    try:
                        with open(filepath, newline='', encoding='utf-8') as csvfile:
                            reader = csv.reader(csvfile)
                            headers = list(next(reader, None))
                            for row in reader:
                                if any(row):
                                    rows.append({h: (row[i] if i < len(row) else '') for i, h in enumerate(headers)})
                    except Exception as e:
                        flash(f"Error al leer el archivo CSV: {str(e)}", "error")
                        return redirect(url_for("main.tables"))
                else:
                    flash("Formato de archivo no soportado. Solo se permiten archivos .xlsx, .xlsm, .xltx, .xltm o .csv", "error")
                    return redirect(url_for("main.tables"))
                
                if not headers or not any(headers):
                    flash("El archivo importado no contiene encabezados válidos.", "error")
                    return redirect(url_for("main.tables"))
                
                # Insertar la tabla en la base de datos
                result = current_app.spreadsheets_collection.insert_one({
                    "owner": owner,
                    "name": table_name,
                    "filename": filename,
                    "headers": headers,
                    "created_at": datetime.utcnow(),
                    "created_by": session["username"],
                    "data": rows,
                    "num_rows": len(rows)
                })
                
                session["selected_headers"] = headers
                return redirect(url_for("main.ver_tabla", table_id=str(result.inserted_id)))
                
            except Exception as e:
                logger.error(f"Error al procesar archivo: {str(e)}", exc_info=True)
                flash(f"Error al procesar el archivo: {str(e)}", "error")
                return redirect(url_for("main.tables"))
        else:
            # Crear tabla nueva desde encabezados ingresados manualmente
            headers_str = request.form.get("table_headers", "").strip()
            headers = [h.strip() for h in headers_str.split(",") if h.strip()] if headers_str else ["Número", "Descripción", "Peso", "Valor"]
            
            if not headers or not any(headers):
                flash("Debes ingresar al menos un encabezado.", "error")
                return redirect(url_for("main.tables"))
            
            try:
                file_id = secrets.token_hex(8)
                filename = f"table_{file_id}.xlsx"
                
                if "UPLOAD_FOLDER" not in current_app.config:
                    flash("Error en la configuración del servidor. Contacte al administrador.", "danger")
                    return redirect(url_for("main.tables"))
                    
                filepath = os.path.join(current_app.config["UPLOAD_FOLDER"], filename)
                
                wb = Workbook()
                hoja = wb.active
                hoja.append(headers)
                wb.save(filepath)
                wb.close()
                
                result = current_app.spreadsheets_collection.insert_one({
                    "owner": owner,
                    "name": table_name,
                    "filename": filename,
                    "headers": headers,
                    "created_at": datetime.utcnow(),
                    "created_by": session["username"],
                    "data": [],
                    "num_rows": 0
                })
                
                session["selected_headers"] = headers
                return redirect(url_for("main.ver_tabla", table_id=str(result.inserted_id)))
            except Exception as e:
                logger.error(f"Error al crear tabla manual: {str(e)}", exc_info=True)
                flash(f"Error al crear la tabla: {str(e)}", "error")
                return redirect(url_for("main.tables"))
    except Exception as e:
        logger.error(f"Error general en tables: {str(e)}", exc_info=True)
        flash("Error al procesar la solicitud. Por favor, inténtelo de nuevo.", "danger")
        return redirect(url_for("main.tables"))







@main_bp.route("/delete_table/<table_id>", methods=["POST"])
def delete_table(table_id):
    # Verificar sesión
    if "username" not in session:
        flash("Debe iniciar sesión para realizar esta acción", "warning")
        return redirect(url_for("auth.login"))

    # Verificar permisos: solo el propietario o admin puede eliminar la tabla
    if session.get("role") == "admin":
        # Los administradores pueden eliminar cualquier tabla
        table = current_app.spreadsheets_collection.find_one({"_id": ObjectId(table_id)})
    else:
        # Los usuarios normales solo pueden eliminar sus propias tablas
        table = current_app.spreadsheets_collection.find_one({"_id": ObjectId(table_id), "owner": session["username"]})

    if not table:
        flash("Tabla no encontrada o no tiene permisos para eliminarla.", "error")
        return redirect(url_for("main.tables"))

    filepath = os.path.join(current_app.config["UPLOAD_FOLDER"], table["filename"])

    if os.path.exists(filepath):
        os.remove(filepath)

    current_app.spreadsheets_collection.delete_one({"_id": ObjectId(table_id)})

    if session.get("selected_table") == table["filename"]:
        session.pop("selected_table", None)

    flash("Tabla eliminada exitosamente.", "success")
    return redirect(url_for("main.tables"))