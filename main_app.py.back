# ==============================================
# üìÑ CONFIGURACIONES INICIALES
# ==============================================

# --- Imports est√°ndar ---
import os
import sys
import logging
import tempfile
import zipfile
import secrets
from typing import Any

# traceback removido - no usado
import hashlib
import time
from datetime import datetime

# --- Imports de terceros ---
import openpyxl  # type: ignore
from bson import ObjectId
from dotenv import load_dotenv
from flask import (
    Flask,
    render_template,
    request,
    redirect,
    send_from_directory,
    url_for,
    flash,
    session,
    abort,
    current_app,
    g,
)
from flask_session import Session  # type: ignore
from werkzeug.security import check_password_hash
from werkzeug.utils import secure_filename
from app.decorators import login_required  # type: ignore

# Importar otros m√≥dulos de utilidad
from app.extensions import init_extensions

# Configurar logging unificado desde el inicio
from app.logging_unified import setup_unified_logging

# Importar Flask-Login y modelo User para configuraci√≥n
from flask_login import LoginManager
from app.models.user import User


def allowed_file(filename: str) -> bool:
    return "." in filename and filename.rsplit(".", 1)[1].lower() in {
        "png",
        "jpg",
        "jpeg",
        "gif",
    }


def eliminar_archivo_imagen(ruta: str) -> None:
    if not ruta:
        return
    if ruta.startswith("s3://"):
        s3_parts = ruta[5:].split("/", 1)
        if len(s3_parts) == 2:
            bucket_name, object_key = s3_parts
            if bucket_name == current_app.config["S3_BUCKET_NAME"]:  # type: ignore
                try:
                    current_app.s3_client.delete_object(  # type: ignore
                        Bucket=bucket_name, Key=object_key
                    )
                except Exception as e:
                    current_app.logger.error(f"Error eliminando imagen de S3: {e}")
    else:
        local_path = os.path.join(
            current_app.config["UPLOAD_FOLDER"], os.path.basename(ruta)
        )
        if os.path.exists(local_path):
            try:
                os.remove(local_path)
            except Exception as e:
                current_app.logger.error(f"Error eliminando imagen local: {e}")


def get_current_spreadsheet() -> str | None:
    selected_table = session.get("selected_table")
    if not selected_table:
        return None
    return os.path.join(current_app.config["UPLOAD_FOLDER"], selected_table)


def leer_datos_excel(filepath: str) -> list[dict[str, Any]]:
    wb = openpyxl.load_workbook(filepath)
    hoja = wb.active
    if hoja is None:
        wb.close()
        return []
    headers = [cell.value for cell in next(hoja.iter_rows(min_row=1, max_row=1))]  # type: ignore
    data = []
    for row in hoja.iter_rows(min_row=2, values_only=True):  # type: ignore
        data.append(dict(zip(headers, row)))
    wb.close()
    return data


# ==============================================
# üìÑ CONFIGURACI√ìN INICIAL DE FLASK
# ==============================================

# --- Cargar variables de entorno ---
load_dotenv()


def create_app():
    print("DEBUG: create_app ejecutado")
    """Crea y configura la aplicaci√≥n Flask"""
    ROOT_DIR = os.path.dirname(os.path.abspath(__file__))
    TEMPLATE_DIR = os.path.join(ROOT_DIR, "app", "templates")
    STATIC_DIR = os.path.join(ROOT_DIR, "app", "static")
    app = Flask(
        __name__,
        template_folder=TEMPLATE_DIR,
        static_folder=STATIC_DIR,
        static_url_path="/static",
    )

    # --- Registrar blueprint de im√°genes ---
    from app.routes.images_routes import images_bp

    app.register_blueprint(images_bp)

    # Cargar configuraci√≥n apropiada seg√∫n el entorno
    if getattr(sys, "frozen", False):
        # Aplicaci√≥n empaquetada - intentar configuraci√≥n embebida
        try:
            from app.config_embedded import EmbeddedConfig  # type: ignore

            app.config.from_object(EmbeddedConfig)
        except ImportError:
            # Fallback a configuraci√≥n normal si no existe embebida
            app.config.from_object("config.Config")
    else:
        # Desarrollo - usar configuraci√≥n normal
        app.config.from_object("config.Config")

    # CONFIGURACI√ìN DE SESI√ìN UNIFICADA
    # La configuraci√≥n de sesiones ahora se maneja centralmente en app/config.py
    # Asegurar que el directorio de sesiones existe
    session_dir = app.config.get("SESSION_FILE_DIR")
    if session_dir:
        if not os.path.isabs(session_dir):
            session_dir = os.path.join(ROOT_DIR, session_dir)
            app.config["SESSION_FILE_DIR"] = session_dir
        os.makedirs(session_dir, exist_ok=True)
        app.logger.info(f"‚úÖ Directorio de sesiones configurado: {session_dir}")
    
    app.logger.info("‚úÖ Configuraci√≥n de sesi√≥n unificada aplicada desde config.py")

    # Inicializar Flask-Session (debe estar despu√©s de configurar app.config)
    Session(app)
    app.logger.info("‚úÖ Flask-Session inicializado correctamente")

    # Inicializar sistema de logging unificado
    setup_unified_logging(app)
    
    # Inicializar extensiones (Flask-Login, Flask-Mail, etc.)
    init_extensions(app)
    app.logger.info(
        "‚úÖ Extensiones inicializadas correctamente (Flask-Login, Flask-Mail, etc.)"
    )

    # Configurar sesi√≥n permanente por defecto
    @app.before_request
    def make_session_permanent():
        session.permanent = True

    # Inicializar la conexi√≥n global a MongoDB (para funciones legacy y modelos)
    try:
        from app.database import initialize_db, get_mongo_client, get_mongo_db

        initialize_db(app)
        app.logger.info("‚úÖ Conexi√≥n global a MongoDB inicializada (initialize_db)")
        # Refuerza la asignaci√≥n de app.db y colecciones SIEMPRE tras inicializar
        client = get_mongo_client()
        db = get_mongo_db()
        app.mongo_client = client  # type: ignore
        app.db = db  # type: ignore
        if db is not None:
            app.users_collection = db["users"]  # type: ignore
            app.resets_collection = db["password_resets"]  # type: ignore
            app.catalog_collection = db["67b8c24a7fdc72dd4d8703cf"]  # type: ignore
            app.spreadsheets_collection = db["spreadsheets"]  # type: ignore
        else:
            app.users_collection = None  # type: ignore
            app.resets_collection = None  # type: ignore
            app.catalog_collection = None  # type: ignore
            app.spreadsheets_collection = None  # type: ignore
    except Exception as e:
        app.logger.error(f"‚ùå Error inicializando la conexi√≥n global a MongoDB: {e}")
        app.db = None  # type: ignore
        app.users_collection = None  # type: ignore
        app.resets_collection = None  # type: ignore
        app.catalog_collection = None  # type: ignore
        app.spreadsheets_collection = None  # type: ignore

    # =================== FUNCIONES AUXILIARES ===================
    # (Eliminar las definiciones internas de eliminar_archivo_imagen, get_current_spreadsheet y leer_datos_excel aqu√≠)

    # =================== RUTAS Y HANDLERS ===================
    # (Las rutas pueden ahora usar current_app.users_collection, etc.)
    # Ejemplo de uso en una ruta:
    # usuario = current_app.users_collection.find_one({...})
    # s3 = current_app.s3_client
    # bucket = current_app.S3_BUCKET_NAME
    # ...

    # --- Versi√≥n CSS autom√°tica para evitar cach√© ---
    CSS_VERSION = datetime.now().strftime("%Y%m%d%H%M%S")

    # --- Funci√≥n para saber si un valor es flotante ---
    def is_float(value):
        try:
            float(value)
            return True
        except (ValueError, TypeError):
            return False

    # --- Inyectar variables globales en todas las plantillas ---
    @app.context_processor
    def inject_template_vars():
        return {"now": datetime.now(), "css_version": CSS_VERSION}

    # --- Configurar archivos est√°ticos personalizados ---
    @app.route("/static/<path:filename>")
    def custom_static(filename):
        static_dir = os.path.join(ROOT_DIR, "app", "static")
        try:
            app.logger.info(
                f"Intentando servir archivo est√°tico: {filename} desde {static_dir}"
            )

            # Verificar que el archivo existe
            full_path = os.path.join(static_dir, filename)
            if not os.path.exists(full_path):
                app.logger.error(f"Archivo no encontrado: {full_path}")
                abort(404)

            return send_from_directory(static_dir, filename)
        except Exception as e:
            app.logger.error(f"Error sirviendo archivo est√°tico {filename}: {str(e)}")
            app.logger.error(f"Ruta completa: {os.path.join(static_dir, filename)}")
            abort(404)

    # --- Decorador para rutas protegidas ---
    # def login_required(f):
    #     def wrapper(*args, **kwargs):
    #         if 'user_id' not in session:
    #             flash('Debes iniciar sesi√≥n primero.', 'warning')
    #             return redirect(url_for('auth.login'))
    #         return f(*args, **kwargs)
    #     wrapper.__name__ = f.__name__
    #     return wrapper

    # Registrar blueprints principales
    from app.routes.main_routes import main_bp
    from app.routes.catalogs_routes import catalogs_bp
    from app.routes.catalog_images_routes import image_bp
    from app.routes.usuarios_routes import usuarios_bp
    from app.routes.admin_routes import (
        admin_bp,
        admin_logs_bp,
    )  # Importar tambi√©n admin_logs_bp
    from app.routes.error_routes import errors_bp
    from app.routes.emergency_access import emergency_bp

    # Debug blueprints ya registrados en otras partes
    from app.routes.scripts_routes import (
        scripts_bp,
    )  # Blueprint para gesti√≥n de scripts
    from app.routes.maintenance_routes import (
        maintenance_bp,
    )  # Blueprint para mantenimiento
    from app.routes.dev_template import (
        bp_dev_template,
    )  # Blueprint para plantilla de desarrollo

    print("ANTES DE BLUEPRINTS", app.db)  # type: ignore
    app.register_blueprint(main_bp)
    app.register_blueprint(catalogs_bp)
    app.register_blueprint(image_bp)
    app.register_blueprint(usuarios_bp)
    app.register_blueprint(admin_bp, url_prefix="/admin")
    app.register_blueprint(
        admin_logs_bp, url_prefix="/admin"
    )  # Registrar admin_logs_bp
    app.register_blueprint(
        scripts_bp
    )  # Blueprint para gesti√≥n de scripts (/admin/tools)
    app.register_blueprint(
        maintenance_bp, url_prefix="/admin"
    )  # Blueprint para mantenimiento
    app.register_blueprint(bp_dev_template)  # Blueprint para plantilla de desarrollo
    app.register_blueprint(errors_bp)
    app.register_blueprint(emergency_bp)  # <-- REGISTRO DE EMERGENCIA
    print("DESPU√âS DE BLUEPRINTS", app.db)  # type: ignore

    # Los blueprints de diagn√≥stico ya fueron importados y registrados arriba
    app.logger.info("‚úÖ Todos los blueprints de diagn√≥stico registrados correctamente")

    # A√±adir rutas de prueba de sesi√≥n directamente en la aplicaci√≥n principal
    @app.route("/prueba_sesion")
    def prueba_sesion():
        """Ruta simple para probar la persistencia de sesiones."""
        # A√±adir un valor a la sesi√≥n
        session["prueba_timestamp"] = datetime.now().isoformat()
        session["contador"] = session.get("contador", 0) + 1
        session.modified = True

        # Preparar respuesta HTML
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Prueba de Sesi√≥n</title>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
        </head>
        <body>
            <div class="container mt-4">
                <h1>Prueba de Sesi√≥n</h1>

                <div class="alert alert-info">
                    <p>Esta p√°gina permite verificar que las sesiones est√°n funcionando correctamente.</p>
                    <p>Si el contador aumenta al recargar la p√°gina, las sesiones est√°n funcionando correctamente.</p>
                </div>

                <div class="card mb-4">
                    <div class="card-header bg-primary text-white">
                        <h5 class="mb-0">Estado de la Sesi√≥n</h5>
                    </div>
                    <div class="card-body">
                        <p><strong>Timestamp:</strong> {session.get("prueba_timestamp", "No disponible")}</p>
                        <p><strong>Contador:</strong> {session.get("contador", 0)}</p>
                        <p><strong>Sesi√≥n Permanente:</strong> {session.permanent}</p>
                        <p><strong>ID de Sesi√≥n:</strong> {request.cookies.get(app.config.get("SESSION_COOKIE_NAME", ""), "No disponible")}</p>

                        <h6 class="mt-3">Contenido completo de la sesi√≥n:</h6>
                        <pre>{dict(session)}</pre>

                        <div class="mt-3">
                            <a href="/prueba_sesion" class="btn btn-primary">Actualizar</a>
                            <a href="/prueba_sesion/limpiar" class="btn btn-danger">Limpiar sesi√≥n</a>
                            <a href="/prueba_sesion/test-cookie" class="btn btn-warning">Probar Cookie</a>
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header bg-info text-white">
                        <h5 class="mb-0">Configuraci√≥n de Sesi√≥n</h5>
                    </div>
                    <div class="card-body">
                        <p><strong>SESSION_TYPE:</strong> {app.config.get("SESSION_TYPE", "No configurado")}</p>
                        <p><strong>SESSION_FILE_DIR:</strong> {app.config.get("SESSION_FILE_DIR", "No configurado")}</p>
                        <p><strong>SESSION_COOKIE_NAME:</strong> {app.config.get("SESSION_COOKIE_NAME", "No configurado")}</p>
                        <p><strong>SESSION_COOKIE_SECURE:</strong> {app.config.get("SESSION_COOKIE_SECURE", False)}</p>
                        <p><strong>SESSION_COOKIE_HTTPONLY:</strong> {app.config.get("SESSION_COOKIE_HTTPONLY", True)}</p>
                        <p><strong>SESSION_COOKIE_SAMESITE:</strong> {app.config.get("SESSION_COOKIE_SAMESITE", "No configurado")}</p>
                        <p><strong>SESSION_REFRESH_EACH_REQUEST:</strong> {app.config.get("SESSION_REFRESH_EACH_REQUEST", False)}</p>
                        <p><strong>SESSION_USE_SIGNER:</strong> {app.config.get("SESSION_USE_SIGNER", False)}</p>
                        <p><strong>PERMANENT_SESSION_LIFETIME:</strong> {app.config.get("PERMANENT_SESSION_LIFETIME", "No configurado")}</p>
                        <p><strong>SECRET_KEY:</strong> {"*" * len(str(app.config.get("SECRET_KEY", "")))}</p>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header bg-secondary text-white">
                        <h5 class="mb-0">Cookies Recibidas</h5>
                    </div>
                    <div class="card-body">
                        <pre>{request.cookies}</pre>
                    </div>
                </div>
            </div>
        </body>
        </html>
        """
        return html

    @app.route("/prueba_sesion/limpiar")
    def prueba_sesion_limpiar():
        """Limpia la sesi√≥n actual."""
        session.clear()
        return redirect("/prueba_sesion")

    @app.route("/prueba_sesion/test-cookie")
    def prueba_sesion_test_cookie():
        """Prueba la configuraci√≥n de cookies."""
        resp = redirect("/prueba_sesion")
        resp.set_cookie("test_cookie", "valor_de_prueba", max_age=3600)
        return resp

    # Ruta de acceso directo a cat√°logos
    @app.route("/acceso_directo_catalogs")
    def acceso_directo_catalogs():
        # Establecer datos de sesi√≥n para el administrador
        session["logged_in"] = True
        session["email"] = "admin@example.com"
        session["username"] = "admin"
        session["role"] = "admin"
        session["name"] = "Administrador"

        app.logger.info("Sesi√≥n establecida para administrador mediante acceso directo")
        app.logger.info(f"Datos de sesi√≥n: {dict(session)}")

        # Redirigir a los cat√°logos
        return redirect(url_for("catalogs.list"))

    # Ruta de acceso directo para usuario normal
    @app.route("/acceso_directo_usuario")
    def acceso_directo_usuario():
        # Establecer datos de sesi√≥n para el usuario normal
        session["logged_in"] = True
        session["email"] = "usuario@example.com"
        session["username"] = "usuario"
        session["role"] = "user"
        session["name"] = "Usuario Normal"

        app.logger.info(
            "Sesi√≥n establecida para usuario normal mediante acceso directo"
        )
        app.logger.info(f"Datos de sesi√≥n: {dict(session)}")

        # Redirigir a los cat√°logos
        return redirect(url_for("catalogs.list"))

    def ensure_db():
        from flask import g
        from app.database import get_mongo_db, get_mongo_client

        client = get_mongo_client()
        db = get_mongo_db()
        g.mongo_client = client
        g.db = db
        if db is not None:
            g.users_collection = db["users"]
            g.resets_collection = db["password_resets"]
            g.spreadsheets_collection = db["spreadsheets"]
        else:
            g.users_collection = None
            g.resets_collection = None
            g.spreadsheets_collection = None

    app.before_request(ensure_db)

    # Registrar blueprint de autenticaci√≥n
    from app.routes.auth_routes import auth_bp
    app.register_blueprint(auth_bp, url_prefix="/auth")

    # Rutas de prueba directas
    @app.route("/ping")
    def ping():
        return "pong"

    @app.route("/test_system_status_direct")
    def test_system_status_direct():
        """Endpoint de prueba directo para el estado del sistema."""
        import psutil  # type: ignore
        import platform
        import getpass
        from datetime import datetime
        from flask import jsonify

        try:
            # Obtener informaci√≥n de memoria
            mem = psutil.virtual_memory()
            
            # Obtener informaci√≥n de CPU
            cpu_percent = psutil.cpu_percent(interval=0.1)
            
            # Obtener informaci√≥n de disco
            import shutil
            total, used, free = shutil.disk_usage("/")
            
            # Informaci√≥n del sistema
            so = platform.system() + " " + platform.release()
            arquitectura = platform.machine()
            usuario = getpass.getuser()
            hora = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            
            # Estructura de datos compatible con el JavaScript del dashboard
            system_data = {
                "status": "success",
                "data": {
                    "system_status": {
                        "memory_usage": {
                            "percent": round(mem.percent, 1),
                            "total_mb": round(mem.total / (1024**2), 2),
                            "used_mb": round(mem.used / (1024**2), 2),
                            "available_mb": round(mem.available / (1024**2), 2)
                        },
                        "cpu_usage": {
                            "percent": round(cpu_percent, 1)
                        },
                        "disk_usage": {
                            "percent": round((used / total) * 100, 1),
                            "total_gb": round(total / (1024**3), 2),
                            "used_gb": round(used / (1024**3), 2),
                            "free_gb": round(free / (1024**3), 2)
                        },
                        "system_details": {
                            "os": so,
                            "architecture": arquitectura,
                            "user": usuario,
                            "timestamp": hora
                        }
                    }
                }
            }
            
            return jsonify(system_data)
            
        except Exception as e:
            return jsonify({
                "status": "error",
                "message": f"Error al obtener estado del sistema: {str(e)}",
                "data": {
                    "system_status": {
                        "memory_usage": {
                            "percent": 0,
                            "total_mb": 0,
                            "used_mb": 0,
                            "available_mb": 0
                        },
                        "cpu_usage": {
                            "percent": 0
                        },
                        "disk_usage": {
                            "percent": 0,
                            "total_gb": 0,
                            "used_gb": 0,
                            "free_gb": 0
                        }
                    }
                }
            }), 500

    return app


app = create_app()

if __name__ == "__main__":
    port = 5001
    if len(sys.argv) > 1 and sys.argv[1] == "--port" and len(sys.argv) > 2:
        try:
            port = int(sys.argv[2])
        except ValueError:
            port = 5001
    app.run(debug=False, host="0.0.0.0", port=port)

# ==============================================
# üìÑ INICIALIZACI√ìN DE VARIABLES GLOBALES
# ==============================================

# Variables para carpetas
ROOT_DIR = os.path.dirname(os.path.abspath(__file__))
SPREADSHEET_FOLDER = os.path.join(ROOT_DIR, "spreadsheets")
UPLOAD_FOLDER = os.path.join(ROOT_DIR, "imagenes_subidas")

# Extensiones de imagen permitidas
ALLOWED_EXTENSIONS = {"png", "jpg", "jpeg", "gif"}

# Versi√≥n de CSS para cache busting
CSS_VERSION = datetime.now().strftime("%Y%m%d%H%M%S")

# Asegurar que las carpetas necesarias existan
os.makedirs(SPREADSHEET_FOLDER, exist_ok=True)
os.makedirs(UPLOAD_FOLDER, exist_ok=True)

# ==============================================
# üìÑ CONFIGURACI√ìN DE LOGGING GLOBAL UNIFICADA
# ==============================================
# El logging ahora se maneja centralmente en app/logging_unified.py

# Manejo de excepciones no capturadas
def handle_exception(exc_type, exc_value, exc_traceback):
    if not issubclass(exc_type, KeyboardInterrupt):
        logging.error(
            "Excepci√≥n no capturada", exc_info=(exc_type, exc_value, exc_traceback)
        )

sys.excepthook = handle_exception

# ==============================================
# üìÑ FUNCIONES PARA SUBIDA Y GESTI√ìN DE ARCHIVOS EN S3
# ==============================================


def upload_file_to_s3(
    file_path: str,
    object_name: str | None = None,
    max_retries: int = 3,
    delete_local: bool = True,
) -> bool:
    """Sube un archivo a S3, verifica subida y elimina el local si √©xito"""
    if object_name is None:
        object_name = os.path.basename(file_path)

    if not os.path.exists(file_path):
        app.logger.error(f"El archivo {file_path} no existe.")
        return False

    successful = False
    attempt = 0
    while attempt < max_retries and not successful:
        attempt += 1
        try:
            current_app.s3_client.upload_file(  # type: ignore
                file_path,
                current_app.config["S3_BUCKET_NAME"],  # type: ignore
                object_name,
            )
            current_app.s3_client.head_object(  # type: ignore
                Bucket=current_app.config["S3_BUCKET_NAME"],  # type: ignore
                Key=object_name,
            )
            successful = True
            app.logger.info(f"‚úÖ Archivo {object_name} subido a S3 exitosamente")
        except Exception as e:
            app.logger.error(
                f"‚ùå Intento {attempt}: Error al subir {object_name}: {str(e)}"
            )
            if attempt < max_retries:
                time.sleep(2**attempt)

    if successful and delete_local:
        try:
            os.remove(file_path)
            app.logger.info(f"üóëÔ∏è Archivo local eliminado: {file_path}")
        except Exception as e:
            app.logger.warning(f"‚ö†Ô∏è No se pudo eliminar {file_path}: {e}")

    return successful


def delete_file_from_s3(object_name):
    """Elimina un archivo de un bucket S3"""
    try:
        current_app.s3_client.delete_object(  # type: ignore
            Bucket=current_app.config["S3_BUCKET_NAME"],  # type: ignore
            Key=object_name,
        )
        app.logger.info(f"‚úÖ Archivo eliminado de S3: {object_name}")
        return True
    except Exception as e:
        app.logger.error(f"‚ùå Error eliminando {object_name} de S3: {str(e)}")
        return False


def get_s3_url(object_name, expiration=3600):
    """Genera una URL firmada para acceder temporalmente a un objeto en S3"""
    try:
        url = current_app.s3_client.generate_presigned_url(  # type: ignore
            "get_object",
            Params={"Bucket": current_app.config["S3_BUCKET_NAME"], "Key": object_name},  # type: ignore
            ExpiresIn=expiration,
        )
        return url
    except Exception as e:
        app.logger.error(f"Error generando URL firmada para {object_name}: {e}")
        return None


# ==============================================
# üîê RUTAS DE AUTENTICACI√ìN
# ==============================================

# Imports duplicados removidos - ya est√°n al inicio del archivo


def verify_scrypt_password(stored_hash, provided_password):
    """
    Verifica una contrase√±a usando el hash scrypt
    """
    try:
        # Extraer los par√°metros del hash almacenado
        parts = stored_hash.split("$")
        if len(parts) != 4:
            return False
        salt = parts[2]
        stored_hash_val = parts[3]
        # Generar el hash de la contrase√±a proporcionada usando hashlib.scrypt
        # Par√°metros corregidos: n=16384, r=8, p=1 (valores m√°s seguros y compatibles)
        new_hash = hashlib.scrypt(
            provided_password.encode("utf-8"),
            salt=salt.encode("utf-8"),
            n=16384,
            r=8,
            p=1,
            dklen=64,
        )
        # Comparar los hashes
        return stored_hash_val == new_hash.hex()
    except Exception as e:
        print(f"Error verificando contrase√±a scrypt: {str(e)}")
        # Si falla scrypt, intentar con werkzeug como fallback
        try:
            return check_password_hash(stored_hash, provided_password)
        except Exception as e2:
            print(f"Error verificando contrase√±a con werkzeug: {str(e2)}")
            return False


# ==============================================
# üìã RUTAS PRINCIPALES (Tablas, Cat√°logo, Archivos)
# ==============================================


# --- Home: Decide a d√≥nde enviar al usuario ---
@app.route("/")
def home():
    if not (session.get("username") or session.get("email")):
        return render_template("welcome.html")
    if "selected_table" in session:
        return redirect(url_for("catalog"))
    else:
        return redirect(url_for("tables"))


# --- P√°gina de bienvenida ---
@app.route("/welcome")
def welcome():
    return render_template("welcome.html", css_version=CSS_VERSION)


# --- Seleccionar una tabla ---
@app.route("/select_table/<table_id>")
@login_required
def select_table(table_id):
    # owner = session.get("username") or session.get("email")  # No usado
    table = current_app.spreadsheets_collection.find_one({"_id": ObjectId(table_id)})  # type: ignore
    if not table:
        flash("Tabla no encontrada.", "error")
        return redirect(url_for("tables"))
    session["selected_table"] = table["filename"]
    session["selected_table_id"] = str(table["_id"])
    session["selected_table_name"] = table["name"]
    return redirect(url_for("catalog"))


# --- Cat√°logo: Mostrar los registros de una tabla ---
@app.route("/catalog", methods=["GET", "POST"])
def catalog():
    if "username" not in session:
        return redirect(url_for("welcome"))
    if "selected_table" not in session:
        flash("Por favor, selecciona una tabla.", "warning")
        return redirect(url_for("tables"))
    selected_table = session["selected_table"]
    table_info = current_app.spreadsheets_collection.find_one(  # type: ignore
        {"filename": selected_table}
    )
    if not table_info:
        flash("La tabla seleccionada no existe.", "error")
        return redirect(url_for("tables"))
    # Control de acceso: solo admin o due√±o puede ver
    # Verificaci√≥n de rol desactivada)
    headers = table_info.get("headers", [])

    # Mostrar registros ordenados por n√∫mero
    pipeline = [
        {"$match": {"table": selected_table}},
        {
            "$addFields": {
                "NumeroOrdenacion": {
                    "$toInt": {"$ifNull": [{"$toInt": "$N√∫mero"}, "$N√∫mero"]}
                }
            }
        },
        {"$sort": {"NumeroOrdenacion": 1}},
    ]
    registros = list(current_app.catalog_collection.aggregate(pipeline))  # type: ignore

    # M√©todo POST: Insertar nuevo registro
    if request.method == "POST":
        form_data = {k.strip(): v.strip() for k, v in request.form.items()}

        id_field = headers[0]  # Normalmente "N√∫mero" o similar

        if not form_data.get(id_field):
            flash(f"Error: El campo {id_field} es obligatorio.", "error")
            return render_template("index.html", data=registros, headers=headers)

        if any(item.get(id_field) == form_data[id_field] for item in registros):
            flash(
                f"Error: Ya existe un registro con {id_field} {form_data[id_field]}.",
                "error",
            )
            return render_template("index.html", data=registros, headers=headers)

        nuevo_registro = {"N√∫mero": len(registros) + 1, "table": selected_table}

        for header in headers:
            safe_header = header.replace(" ", "_").replace(".", "_")
            nuevo_registro[safe_header] = form_data.get(header, "")

        # Manejo de im√°genes (se suben a S3)
        files = request.files.getlist("imagenes")
        rutas_imagenes = []
        for file in files[:3]:
            if file and file.filename and allowed_file(file.filename):
                filename = secure_filename(file.filename)
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                unique_filename = f"{timestamp}_{secrets.token_hex(4)}_{filename}"
                temp_path = os.path.join(app.config["UPLOAD_FOLDER"], unique_filename)
                file.save(temp_path)

                if upload_file_to_s3(temp_path, unique_filename):
                    rutas_imagenes.append(
                        f"s3://{current_app.config['S3_BUCKET_NAME']}/{unique_filename}"  # type: ignore
                    )

        nuevo_registro["Imagenes"] = rutas_imagenes

        current_app.catalog_collection.insert_one(nuevo_registro)  # type: ignore
        return redirect(url_for("catalog"))

    # M√©todo GET: Mostrar registros
    return render_template("index.html", data=registros, headers=headers)


# ==============================================
# ‚úèÔ∏è RUTAS PARA EDITAR Y ELIMINAR REGISTROS
# ==============================================


# --- Editar un registro ---
@app.route("/editar/<id>", methods=["GET", "POST"])
def editar(id):
    if "username" not in session:
        return redirect(url_for("auth.login"))

    if "selected_table" not in session:
        flash("Selecciona una tabla primero.", "warning")
        return redirect(url_for("tables"))

    selected_table = session["selected_table"]
    table_info = current_app.spreadsheets_collection.find_one(  # type: ignore
        {"filename": selected_table}
    )

    if not table_info:
        flash("Tabla no encontrada.", "error")
        return redirect(url_for("tables"))

    headers = table_info.get("headers", [])
    # id_field = headers[0]  # No usado
    # safe_id_field = id_field.replace(" ", "_").replace(".", "_")  # No usado

    registro = current_app.catalog_collection.find_one({"_id": ObjectId(id)})  # type: ignore

    if not registro:
        flash("Registro no encontrado.", "error")
        return redirect(url_for("catalog"))

    # --- GET: Mostrar el formulario de edici√≥n ---
    if request.method == "GET":
        headers_form = [h for h in headers if h != "Imagenes"]
        return render_template(
            "editar.html",
            registro=registro,
            headers=headers_form,
            imagenes_actuales=registro.get("Imagenes", [None, None, None]),
        )

    # --- POST: Guardar cambios ---
    update_data = {"N√∫mero": registro["N√∫mero"], "table": selected_table}

    for header in headers:
        if header != "Imagenes" and header != "N√∫mero":
            safe_header = header.replace(" ", "_").replace(".", "_")
            update_data[safe_header] = request.form.get(header, "").strip()

    # Manejo de nuevas im√°genes
    rutas_imagenes = registro.get("Imagenes", [None, None, None])

    for idx, field_name in enumerate(["imagen1", "imagen2", "imagen3"]):
        imagen = request.files.get(field_name)
        if imagen and imagen.filename and allowed_file(imagen.filename):
            filename = secure_filename(imagen.filename)
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            unique_filename = f"{timestamp}_{secrets.token_hex(4)}_{filename}"
            temp_path = os.path.join(app.config["UPLOAD_FOLDER"], unique_filename)
            imagen.save(temp_path)

            if upload_file_to_s3(temp_path, unique_filename):
                rutas_imagenes[idx] = (
                    f"s3://{current_app.config['S3_BUCKET_NAME']}/{unique_filename}"
                )

    # Manejar eliminaci√≥n de im√°genes
    for idx in range(3):
        if request.form.get(f"remove_img{idx + 1}") == "on":
            eliminar_archivo_imagen(rutas_imagenes[idx])
            rutas_imagenes[idx] = None

    update_data["Imagenes"] = rutas_imagenes

    # Actualizar el registro en MongoDB
    current_app.catalog_collection.update_one(  # type: ignore
        {"_id": ObjectId(id)}, {"$set": update_data}
    )

    flash("Registro actualizado correctamente.", "success")
    return redirect(url_for("catalog"))


# --- Eliminar una tabla completa ---
@app.route("/delete_table/<table_id>", methods=["POST"])
def delete_table(table_id):
    if "username" not in session:
        return redirect(url_for("auth.login"))

    table = current_app.spreadsheets_collection.find_one(  # type: ignore
        {"_id": ObjectId(table_id), "owner": session["username"]}
    )

    if not table:
        flash("Tabla no encontrada o no tienes permiso.", "error")
        return redirect(url_for("tables"))

    filepath = os.path.join(SPREADSHEET_FOLDER, table["filename"])

    if os.path.exists(filepath):
        os.remove(filepath)

    current_app.spreadsheets_collection.delete_one({"_id": ObjectId(table_id)})  # type: ignore

    if session.get("selected_table") == table["filename"]:
        session.pop("selected_table", None)

    flash("Tabla eliminada exitosamente.", "success")
    return redirect(url_for("tables"))


# ==============================================
# üì¶ RUTAS PARA DESCARGAR CAT√ÅLOGO COMO ZIP
# ==============================================

# tempfile y zipfile ya importados al inicio del archivo


@app.route("/descargar-excel")
def descargar_excel():
    if "username" not in session:
        return redirect(url_for("auth.login"))

    spreadsheet_path = get_current_spreadsheet()

    if not spreadsheet_path or not os.path.exists(spreadsheet_path):
        return "‚ùå El Excel no existe a√∫n."

    # Crear un archivo temporal ZIP
    temp_zip = tempfile.NamedTemporaryFile(delete=False, suffix=".zip")
    with zipfile.ZipFile(temp_zip.name, "w") as zf:
        # Incluir el Excel
        zf.write(spreadsheet_path, arcname=os.path.basename(spreadsheet_path))

        # Incluir im√°genes (locales o de S3)
        data = leer_datos_excel(spreadsheet_path)
        image_paths = set()

        for row in data:
            for ruta in row.get("Imagenes", []):
                if ruta:
                    if ruta.startswith("s3://"):
                        try:
                            s3_parts = ruta[5:].split("/", 1)
                            if len(s3_parts) == 2:
                                bucket_name, object_key = s3_parts
                                if bucket_name == current_app.config["S3_BUCKET_NAME"]:  # type: ignore
                                    temp_path = os.path.join(
                                        tempfile.gettempdir(),
                                        os.path.basename(object_key),
                                    )
                                    current_app.s3_client.download_file(  # type: ignore
                                        bucket_name, object_key, temp_path
                                    )
                                    image_paths.add(temp_path)
                        except Exception as e:
                            print(f"Error al descargar imagen S3: {e}")
                    else:
                        local_path = os.path.join(app.root_path, ruta.lstrip("/"))
                        if os.path.exists(local_path):
                            image_paths.add(local_path)

        for img_path in image_paths:
            zf.write(img_path, arcname=f"imagenes/{os.path.basename(img_path)}")

    return send_from_directory(
        directory=os.path.dirname(temp_zip.name),
        path=os.path.basename(temp_zip.name),
        as_attachment=True,
        download_name="catalogo.zip",
    )


# ==============================================
# üñºÔ∏è RUTA PARA SERVIR IM√ÅGENES SUBIDAS
# ==============================================


# ==============================================
# üî¢ RENOMBRAR REGISTROS AUTOM√ÅTICAMENTE
# ==============================================


def renumerar_registros(table_name):
    """Renumera todos los registros de una tabla espec√≠fica en orden secuencial"""
    registros = list(
        current_app.catalog_collection.find({"table": table_name}).sort("N√∫mero", 1)  # type: ignore
    )

    for i, registro in enumerate(registros, 1):
        if registro.get("N√∫mero") != i:
            current_app.catalog_collection.update_one(  # type: ignore
                {"_id": registro["_id"]}, {"$set": {"N√∫mero": i}}
            )

    return len(registros)


@app.route("/renumerar/<table_name>")
def renumerar(table_name):
    """Renumera todos los registros de una tabla y redirecciona al cat√°logo"""
    if "username" not in session:
        return redirect(url_for("welcome"))

    try:
        total = renumerar_registros(table_name)
        flash(f"‚úÖ Se renumeraron {total} registros.", "success")
    except Exception as e:
        flash(f"‚ùå Error al renumerar registros: {e}", "error")

    session["selected_table"] = table_name
    return redirect(url_for("catalog"))


# ==============================================
# ‚ùå MANEJO DE ERRORES PERSONALIZADOS
# ==============================================


@app.errorhandler(404)
def page_not_found(e):
    """Manejo de error 404: P√°gina no encontrada"""
    return render_template("not_found.html"), 404


@app.errorhandler(500)
def server_error(e):
    """Manejo de error 500: Error interno del servidor"""
    return render_template("error.html", error=str(e)), 500


# ==============================================
# üé® RUTA PARA PROBAR LOS ESTILOS VISUALES
# ==============================================


@app.route("/test_styles")
def test_styles():
    """Ruta para probar el correcto funcionamiento de los CSS y otros recursos est√°ticos"""
    return render_template("test_styles.html")


# ==============================================
# üõ†Ô∏è GESTOR DE SCRIPTS
# ==============================================

# Estas rutas han sido trasladadas al blueprint scripts_bp en scripts_routes.py
# con el prefijo /admin/tools

# @app.route('/tools')
# @admin_required
# def tools_dashboard():
#     """Ruta para acceder al gestor de scripts del sistema"""
#     import os
#     import glob
#
#     # Definir las categor√≠as de scripts
#     script_categories = {
#         'maintenance': {
#             'name': 'Mantenimiento',
#             'description': 'Scripts para iniciar, supervisar y mantener la aplicaci√≥n',
#             'path': os.path.join(ROOT_DIR, 'scripts/maintenance')
#         },
#         'organization': {
#             'name': 'Organizaci√≥n',
#             'description': 'Scripts para organizar y limpiar la estructura del proyecto',
#             'path': ROOT_DIR
#         },
#         'deployment': {
#             'name': 'Despliegue',
#             'description': 'Scripts relacionados con el despliegue de la aplicaci√≥n',
#             'path': os.path.join(ROOT_DIR, 'scripts/deployment')
#         },
#         'system': {
#             'name': 'Sistema',
#             'description': 'Scripts para tareas del sistema operativo y configuraci√≥n',
#             'path': os.path.join(ROOT_DIR, 'scripts/system')
#         }
#     }
#
#     # Recopilar todos los scripts
#     scripts = []
#
#     # Scripts de mantenimiento
#     maintenance_scripts = glob.glob(os.path.join(script_categories['maintenance']['path'], '*.sh'))
#     for script_path in maintenance_scripts:
#         scripts.append({
#             'name': os.path.basename(script_path),
#             'path': script_path,
#             'category': 'maintenance',
#             'description': 'Script de mantenimiento del sistema'
#         })
#
#     # Scripts de organizaci√≥n
#     organization_scripts = [
#         os.path.join(ROOT_DIR, 'cleanup_duplicates.sh'),
#         os.path.join(ROOT_DIR, 'organize_root_scripts.sh'),
#         os.path.join(ROOT_DIR, 'reorganize_project.sh')
#     ]
#     for script_path in organization_scripts:
#         if os.path.exists(script_path):
#             scripts.append({
#                 'name': os.path.basename(script_path),
#                 'path': script_path,
#                 'category': 'organization',
#                 'description': 'Script de organizaci√≥n del proyecto'
#             })
#
#     # Otros scripts en el directorio ra√≠z
#     root_scripts = glob.glob(os.path.join(ROOT_DIR, '*.sh'))
#     for script_path in root_scripts:
#         if script_path not in organization_scripts:
#             scripts.append({
#                 'name': os.path.basename(script_path),
#                 'path': script_path,
#                 'category': 'system',
#                 'description': 'Script del sistema'
#             })
#
#     return render_template('tools_dashboard.html', scripts=scripts, categories=script_categories)

# @app.route('/tools/view_script')
# @admin_required
# def view_script():
#     """Ruta para ver el contenido de un script"""
#     script_path = request.args.get('path')
#
#     if not script_path:
#         return jsonify({'error': 'No se ha especificado la ruta del script'}), 400

#     # Verificar que el archivo est√° dentro del directorio del proyecto
#     if not script_path.startswith(ROOT_DIR):
#         return jsonify({'error': 'No se permite acceder a archivos fuera del directorio del proyecto'}), 403
#
#     try:
#         with open(script_path, 'r') as file:
#             content = file.read()
#         return jsonify({'content': content, 'name': os.path.basename(script_path)})
#     except Exception as e:
#         return jsonify({'error': f'Error al leer el archivo: {str(e)}'}), 500

# @app.route('/tools/run_script')
# @admin_required
# def run_script():
#     """Ruta para ejecutar un script"""
#     script_path = request.args.get('path')
#
#     if not script_path:
#         return jsonify({'error': 'No se ha especificado la ruta del script'}), 400
#
#     # Verificar que la ruta es v√°lida y apunta a un archivo .sh
#     if not os.path.exists(script_path) or not os.path.isfile(script_path) or not script_path.endswith('.sh'):
#         return jsonify({'error': 'El archivo no existe o no es un script .sh v√°lido'}), 404
#
#     # Verificar que el archivo est√° dentro del directorio del proyecto
#     if not script_path.startswith(ROOT_DIR):
#         return jsonify({'error': 'No se permite ejecutar archivos fuera del directorio del proyecto'}), 403
#
#     # Verificar que el archivo tiene permisos de ejecuci√≥n
#     if not os.access(script_path, os.X_OK):
#         try:
#             os.chmod(script_path, 0o755)
#         except Exception as e:
#             return jsonify({'error': f'No se pudieron establecer permisos de ejecuci√≥n: {str(e)}'}), 500
#
#     # Ejecutar el script y capturar la salida
#     try:
#         import subprocess
#         process = subprocess.Popen(
#             f"cd {os.path.dirname(script_path)} && {script_path}",
#             shell=True,
#             stdout=subprocess.PIPE,
#             stderr=subprocess.PIPE,
#             text=True
#         )
#         stdout, stderr = process.communicate(timeout=30)  # Timeout de 30 segundos
#
#         result = {
#             'script': os.path.basename(script_path),
#             'exit_code': process.returncode,
#             'output': stdout,
#             'error': stderr,
#             'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
#         }
#
#         return jsonify(result)
#     except subprocess.TimeoutExpired:
#         return jsonify({
#             'script': os.path.basename(script_path),
#             'error': 'El script tard√≥ demasiado tiempo en ejecutarse (m√°s de 30 segundos)',
#             'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
#         }), 408
#     except Exception as e:
#         return jsonify({
#             'script': os.path.basename(script_path),
#             'error': f'Error al ejecutar el script: {str(e)}',
#             'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
#         }), 500

# ==============================================
# üî• AJUSTE FINAL: LANZAMIENTO DE LA APP
# ==============================================

# if __name__ == '__main__':
#     app.run(debug=False, host='0.0.0.0')

# ==============================================
# üìÑ RUTAS PARA DASHBOARDS
# ==============================================

# --- Dashboard para usuario normal ---
# (Eliminado: esta ruta ahora est√° en el blueprint main_bp)

# ==============================================
# üîê RUTAS PROTEGIDAS
# ==============================================


# --- Decorador admin_required ya importado desde app.decorators ---
# Las rutas ahora est√°n definidas dentro de la funci√≥n create_app()
